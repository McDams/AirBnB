---
title: "AirBnB"
format: html
editor: visual
---

## 1. Chargement des librairies

```{r}
library(readr)
library(tidyverse)  # Manipulation et Visualisation
library(lubridate)  
library(skimr)      # Statistique
```

## 2. Importation des donn√©es

## 2.1 Paris

## 2.1.1 Listings

```{r}
listings_paris <- read_csv("../data/paris/listings.csv")
```

## 2.1.2 Affichage des premi√®res lignes

```{r}
head(listings_paris)
```

## 2.1.3 Suppression des doublons

```{r}
listings_paris <- listings_paris %>%
  distinct()
```

## 2.1.4 Statistiques descriptives

```{r}
skim(listings_paris)
```

## 2.2 Bordeaux

## 2.2.1 Listings

```{r}
listings_bordeaux <- read_csv("../data/bordeaux/listings.csv")
```

## 2.2.2 Affichage des premi√®res lignes

```{r}
head(listings_bordeaux)
```

## 2.2.3 Suppression des doublons

```{r}
listings_bordeaux <- listings_bordeaux %>%
  distinct()
```

## 2.2.4 Statistiques descriptives

```{r}
skim(listings_bordeaux)
```

## 2.3 Lyon

## 2.3.1 Listings

```{r}
listings_lyon <- read_csv("../data/lyon/listings.csv")
```

## 2.3.2 Affichage des premi√®res lignes

```{r}
head(listings_lyon)
```

## 2.3.3 Suppression des doublons

```{r}
listings_lyon <- listings_lyon %>%
  distinct()
```

## 2.3.4 Statistiques descriptives

```{r}
skim(listings_lyon)
```

## 3. Nettoyage des donn√©es

## 3.1 Paris

## 3.1.1 Listings - Suppression des colonnes inutiles

```{r}
# Suppression de la colonne licence
listings_paris <- listings_paris %>%
  select(-license)

# Suppression de la colonne neighbourhood_group
listings_paris <- listings_paris %>%
  select(-neighbourhood_group)

# V√©rification
head(listings_paris)
```

## 3.1.2 Listings - Remplacement les valeurs NA dans la colonne price

```{r}
# Remplacement des valeurs NA dans la colonne price par la moyenne des prix
mean_price_paris <- mean(listings_paris$price, na.rm = TRUE)
listings_paris <- listings_paris %>%
  mutate(price = ifelse(is.na(price), mean_price_paris, price))

# V√©rification
head(listings_paris)
```

## 3.2 Bordeaux

## 3.2.1 Listings - Suppression des colonnes inutiles

```{r}
# Suppression de la colonne licence
listings_bordeaux <- listings_bordeaux %>%
  select(-license)

# Suppression de la colonne neighbourhood_group
listings_bordeaux <- listings_bordeaux %>%
  select(-neighbourhood_group)

# V√©rification
head(listings_bordeaux)
```

3.2.2 Remplacement des valeurs NA dans la colonne price

```{r}
# Remplacement des valeurs NA dans la colonne price par la moyenne des prix
mean_price_bordeaux <- mean(listings_bordeaux$price, na.rm = TRUE)
listings_bordeaux <- listings_bordeaux %>%
  mutate(price = ifelse(is.na(price), mean_price_bordeaux, price))

# V√©rification
head(listings_bordeaux)
```

## 3.3 Lyon

## 3.3.1 Listings - Suppression des colonnes inutiles

```{r}
# Suppression de la colonne licence
listings_lyon <- listings_lyon %>%
  select(-license)

# Suppression de la colonne neighbourhood_group
listings_lyon <- listings_lyon %>%
  select(-neighbourhood_group)

# V√©rification
head(listings_lyon)
```

## 3.3.2 Listings - Remplacement des valeurs NA dans la colonne price

```{r}
# Remplacement des valeurs NA dans la colonne price par la moyenne des prix
mean_price_lyon <- mean(listings_lyon$price, na.rm = TRUE)
listings_lyon <- listings_lyon %>%
  mutate(price = ifelse(is.na(price), mean_price_lyon, price))

# V√©rification
head(listings_lyon)
```

## 4. Sauvegarde des donn√©es nettoy√©es

```{r}
write_csv(listings_paris, "../data_cleaned/paris/listings_cleaned.csv")
write_csv(listings_bordeaux, "../data_cleaned/bordeaux/listings_cleaned.csv")
write_csv(listings_lyon, "../data_cleaned/lyon/listings_cleaned.csv")
```

## 5. Renommer les fichiers nettoy√©s

```{r}
file.rename("../data_cleaned/paris/listings_cleaned.csv", "../data_cleaned/paris/listings_paris_cleaned.csv")
file.rename("../data_cleaned/bordeaux/listings_cleaned.csv", "../data_cleaned/bordeaux/listings_bordeaux_cleaned.csv")
file.rename("../data_cleaned/lyon/listings_cleaned.csv", "../data_cleaned/lyon/listings_lyon_cleaned.csv")
```

```{r}
listings_paris <- read_csv("../data_cleaned/paris/listings_paris_cleaned.csv")
listings_bordeaux <- read_csv("../data_cleaned/bordeaux/listings_bordeaux_cleaned.csv")
listings_lyon <- read_csv("../data_cleaned/lyon/listings_lyon_cleaned.csv")
```

## 6. Analyse exploratoire des donn√©es (EDA)

## 6.1 Visualisation Globale des datasets

## 6.1.1 Nombre total d'annonces par ville

```{r}
library(tibble)
library(ggplot2)

# Cr√©er un tableau avec le nombre total d'annonces par ville
total_listings <- tibble(
  ville = c("Paris", "Bordeaux", "Lyon"),
  nombre_annonces = c(nrow(listings_paris), nrow(listings_bordeaux), nrow(listings_lyon))
)
# Ajouter une colonne pour la proportion par ville
total_listings <- total_listings %>%
  mutate(proportion = round((nombre_annonces / sum(nombre_annonces)) * 100, 2))

# Afficher le tableau
print(total_listings)

```

## 6.1.2 Visualiser le nombre total d'annonces par ville (Affichage avec les nombres )

## 6.1.2.1 Graphique en barres

```{r}
ggplot(total_listings, aes(x = ville, y = nombre_annonces, fill = ville)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = nombre_annonces), vjust = -0.5) +
  labs(title = "Nombre total d'annonces AirBnB par ville",
       x = "Villes",
       y = "Nombre d'annonces") +
  theme_minimal()

# Sauvegarder le graphique
ggsave("../images/total_listings_by_city.png")
```

## 6.1.2.2 Pie chart: Repartition Bordeaux, Lyon, Paris

```{r}
library(ggplot2)

# Cr√©er un pie chart pour la r√©partition des annonces par ville
ggplot(total_listings, aes(x = "", y = nombre_annonces, fill = ville)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  geom_text(aes(label = paste0(proportion, "%")), 
            position = position_stack(vjust = 0.5)) +
  labs(title = "R√©partition des annonces AirBnB par ville") +
  theme_void()

# Sauvegarder le graphique
ggsave("../images/pie_chart_listings_by_city.png")
```

## 6.2 Analyse des prix des annonces

## 6.2.1 Prix moyen, m√©dian, min, max;

```{r}
price_summary <- function(data, city_name) {
  summary <- data %>%
    summarise(
      ville = city_name,
      prix_moyen = mean(price, na.rm = TRUE),
      prix_median = median(price, na.rm = TRUE),
      prix_min = min(price, na.rm = TRUE),
      prix_max = max(price, na.rm = TRUE)
    )
  return(summary)
}
summary_paris <- price_summary(listings_paris, "Paris")
summary_bordeaux <- price_summary(listings_bordeaux, "Bordeaux")
summary_lyon <- price_summary(listings_lyon, "Lyon")
price_summaries <- bind_rows(summary_paris, summary_bordeaux, summary_lyon)
print(price_summaries)

# Sauvegarder le tableau des r√©sum√©s de prix
write_csv(price_summaries, "../data_cleaned/price_summaries.csv")
```

## 6.2.2 Visualisation des prix moyens par ville

```{r}
ggplot(price_summaries, aes(x = ville, y = prix_moyen, fill = ville)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(prix_moyen, 2)), vjust = -0.5) +
  labs(title = "Prix moyen des annonces AirBnB par ville",
       x = "Villes",
       y = "Prix moyen (‚Ç¨)") +
  theme_minimal()

# Sauvegarder le graphique
ggsave("../images/average_price_by_city.png")
```

## 6.2.3 Distribution des prix (1 histogramme par facett√©)

```{r}
listings_paris <- listings_paris %>%
  mutate(ville = "Paris")
listings_bordeaux <- listings_bordeaux %>%
  mutate(ville = "Bordeaux")
listings_lyon <- listings_lyon %>%
  mutate(ville = "Lyon")
all_listings <- bind_rows(listings_paris, listings_bordeaux, listings_lyon)
ggplot(all_listings, aes(x = price, fill = ville)) +
  geom_histogram(binwidth = 20, position = "dodge", alpha = 0.7) +
  facet_wrap(~ ville) +
  labs(title = "Distribution des prix des annonces AirBnB par ville",
       x = "Prix (‚Ç¨)",
       y = "Nombre d'annonces") +
  theme_minimal()

# Sauvegarder le graphique
ggsave("../images/price_distribution_by_city.png")
```

## 6.3 Avis & notations

## 6.3.1 Rassembler les donn√©es

```{r}
listings_paris <- listings_paris %>% mutate(city = "Paris")
listings_bordeaux <- listings_bordeaux %>% mutate(city = "Bordeaux")
listings_lyon <- listings_lyon %>% mutate(city = "Lyon")

df <- bind_rows(listings_paris, listings_bordeaux, listings_lyon) %>%
  filter(price > 0)
```

## 6.3.2 prix vs nombre de reviews (par ville)

```{r}
ggplot(df, aes(x = number_of_reviews, y = price, color = city)) +
  geom_point(alpha = 0.4) +
  scale_y_log10() +
  labs(
    title = "Prix vs nombre de reviews",
    x = "Nombre de reviews",
    y = "Prix (‚Ç¨)",
    color = "Ville"
  ) +
  theme_minimal()
```

## 6.3.3 prix vs reviews par mois

```{r}
ggplot(df, aes(x = reviews_per_month, y = price, color = city)) +
  geom_point(alpha = 0.4) +
  scale_y_log10() +
  labs(
    title = "Prix vs fr√©quence des reviews",
    x = "Reviews par mois",
    y = "Prix (‚Ç¨)",
    color = "Ville"
  ) +
  theme_minimal()
```

## 6.3.4 prix moyen par niveau de r√©putation

```{r}
df %>%
  mutate(reputation = case_when(
    number_of_reviews == 0 ~ "Aucun avis",
    number_of_reviews < 10 ~ "Peu d'avis",
    number_of_reviews < 50 ~ "Avis mod√©r√©s",
    TRUE ~ "Beaucoup d'avis"
  )) %>%
  group_by(city, reputation) %>%
  summarise(mean_price = mean(price), .groups = "drop") %>%
  ggplot(aes(x = reputation, y = mean_price, fill = city)) +
  geom_col(position = "dodge") +
  labs(
    title = "Prix moyen selon la r√©putation",
    x = "Niveau de r√©putation",
    y = "Prix moyen (‚Ç¨)",
    fill = "Ville"
  ) +
  theme_minimal()
```

## 6.4 Disponibilit√©

## 6.4.1 logements disponibles / non disponibles par ville

```{r}
df <- df %>%
  mutate(disponible = availability_365 > 0)

df %>%
  count(city, disponible) %>%
  group_by(city) %>%
  mutate(prop = n / sum(n)) %>%
  ggplot(aes(x = "", y = prop, fill = disponible)) +
  geom_col(width = 1) +
  coord_polar("y") +
  facet_wrap(~ city) +
  labs(
    title = "Disponibilit√© des logements par ville",
    fill = "Disponible"
  ) +
  theme_void()
```

## 6.4.2 taux de disponibilit√© par ville

```{r}
df %>%
  group_by(city) %>%
  summarise(taux_disponibilite = mean(disponible)) %>%
  ggplot(aes(x = reorder(city, taux_disponibilite), y = taux_disponibilite)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Taux de disponibilit√© par ville",
    x = "Ville",
    y = "Taux de disponibilit√©"
  ) +
  theme_minimal()
```

## 6.4.3 prix vs disponibilit√©

```{r}
ggplot(df, aes(x = availability_365, y = price, color = city)) +
  geom_point(alpha = 0.4) +
  scale_y_log10() +
  labs(
    title = "Prix vs disponibilit√© annuelle",
    x = "Jours disponibles par an",
    y = "Prix (‚Ç¨)",
    color = "Ville"
  ) +
  theme_minimal()
```

## =========================

## 7Ô∏è‚É£ H√¥tes üë§ + 8Ô∏è‚É£ Outliers üö® + 9Ô∏è‚É£ ML ü§ñ + üîü Synth√®se

## =========================

```{r}
library(tidyverse)
library(ggplot2)
library(broom)
library(plotly)

## -------------------------------------------------------
## 0) Fusionner les 3 villes dans 1 seul df + colonnes utiles
## -------------------------------------------------------
listings_paris   <- listings_paris   %>% mutate(city = "Paris")
listings_bordeaux<- listings_bordeaux%>% mutate(city = "Bordeaux")
listings_lyon    <- listings_lyon    %>% mutate(city = "Lyon")

listings_all <- bind_rows(listings_paris, listings_bordeaux, listings_lyon)

#colnames(listings_all)

# S√©curiser les types (au cas o√π)
listings_all <- listings_all %>%
  mutate(
  calculated_host_listings_count = as.numeric(calculated_host_listings_count),
  reviews_per_month = as.numeric(reviews_per_month),
  number_of_reviews = as.numeric(number_of_reviews),
  availability_365 = as.numeric(availability_365),
  price = as.numeric(price)
  )

dir.create("../figures", showWarnings = FALSE, recursive = TRUE)
```

## =======================================================

## 7Ô∏è‚É£ H√¥tes üë§

## =======================================================

## 7.1 Bar chart : h√¥tes avec 1 logement vs multi-logements (par ville)

```{r}

hosts_type <- listings_all %>%
filter(!is.na(calculated_host_listings_count)) %>%
mutate(
host_type = if_else(calculated_host_listings_count <= 1,
"1 logement",
"Multi-logements")
) %>%
count(city, host_type) %>%
group_by(city) %>%
mutate(pct = n / sum(n)) %>%
ungroup()

ggplot(hosts_type, aes(x = host_type, y = n, fill = host_type)) +
geom_col() +
geom_text(aes(label = scales::comma(n)), vjust = -0.5, size = 3) +
facet_wrap(~city) +
labs(
title = "H√¥tes : 1 logement vs multi-logements (par ville)",
x = NULL,
y = "Nombre d'annonces"
) +
theme_minimal()

ggsave("../figures/hosts_single_vs_multi_by_city.png", width = 10, height = 5)

```

## 7.2 Scatter : prix vs nombre de logements de l‚Äôh√¥te (par ville)

```{r}
ggplot(
listings_all %>%
filter(!is.na(calculated_host_listings_count), !is.na(price)),
aes(x = calculated_host_listings_count, y = price)
) +
geom_point(alpha = 0.25) +
geom_smooth(method = "lm", se = FALSE) +
facet_wrap(~city, scales = "free_y") +
labs(
title = "Prix vs nombre de logements de l'h√¥te (impact h√¥tes professionnels)",
x = "Nombre de logements du host",
y = "Prix (‚Ç¨)"
) +
theme_minimal()

ggsave("../figures/price_vs_host_listings_scatter_by_city.png",
width = 10, height = 5)

```

## =======================================================

## 8Ô∏è‚É£ Valeurs aberrantes üö®

## =======================================================

## 8.1 Boxplot : prix par ville

```{r}

ggplot(listings_all %>% filter(!is.na(price)), aes(x = city, y = price, fill = city)) +
  geom_boxplot(outlier.alpha = 0.2) +
  labs(title = "Boxplot des prix par ville (d√©tection outliers)", x = NULL, y = "Prix (‚Ç¨)") +
  theme_minimal()

ggsave("../figures/boxplot_price_by_city.png", width = 8, height = 5)
```

## 8.2 D√©finir un nettoyage simple des outliers (IQR par ville)

```{r}

remove_outliers_iqr <- function(df, col = price) {
  x <- df %>% pull({{col}})
  q1 <- quantile(x, 0.25, na.rm = TRUE)
  q3 <- quantile(x, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  low <- q1 - 1.5 * iqr
  high <- q3 + 1.5 * iqr
  df %>% filter({{col}} >= low, {{col}} <= high)
}

listings_all_clean <- listings_all %>%
  filter(!is.na(price)) %>%
  group_by(city) %>%
  group_modify(~ remove_outliers_iqr(.x, price)) %>%
  ungroup()

```

## 8.3 Histogramme AVANT / APR√àS (facett√© par ville)

```{r}


before_after <- bind_rows(
  listings_all %>% filter(!is.na(price)) %>% mutate(stage = "Avant"),
  listings_all_clean %>% mutate(stage = "Apr√®s")
)

ggplot(before_after, aes(x = price)) +
  geom_histogram(bins = 40, alpha = 0.6) +
  facet_grid(stage ~ city, scales = "free_y") +
  labs(title = "Distribution des prix : avant / apr√®s nettoyage outliers (IQR)", x = "Prix (‚Ç¨)", y = "Nombre") +
  theme_minimal()

ggsave("../figures/hist_price_before_after_outliers.png", width = 12, height = 6)

```

## =======================================================

## 9Ô∏è‚É£ Machine Learning ‚Äì Pr√©diction du prix ü§ñ

## =======================================================

## 9.0 S√©lection features + gestion NA

```{r}


```

## 9.1 Entra√Æner un mod√®le par ville (comparaison R¬≤ + pr√©dictions)

```{r}

ml_df <- listings_all_clean %>%
select(
city,
price,
calculated_host_listings_count,
number_of_reviews,
number_of_reviews_ltm,
reviews_per_month,
availability_365,
room_type
) %>%
mutate(
calculated_host_listings_count = as.numeric(calculated_host_listings_count),
number_of_reviews = as.numeric(number_of_reviews),
number_of_reviews_ltm = as.numeric(number_of_reviews_ltm),
availability_365 = as.numeric(availability_365),
reviews_per_month = if_else(
is.na(reviews_per_month),
mean(reviews_per_month, na.rm = TRUE),
reviews_per_month
),
room_type = as.factor(room_type)
) %>%
drop_na(price, calculated_host_listings_count, availability_365)


```

## 9.2 Tableau R¬≤ comparatif

```{r}
ggplot(ml_df, aes(x = availability_365, y = price)) +
geom_point(alpha = 0.25) +
geom_smooth(method = "lm", se = FALSE) +
facet_wrap(~city, scales = "free_y") +
labs(
title = "R√©gression lin√©aire simple : Prix ~ Disponibilit√© (availability_365)",
x = "Disponibilit√© sur 365 jours",
y = "Prix (‚Ç¨)"
) +
theme_minimal()


```

## 9.3 Scatter : prix r√©el vs prix pr√©dit (par ville) - mod√®le multiple

```{r}

set.seed(42)

models <- ml_df %>%
group_by(city) %>%
group_map(~{
idx <- sample(seq_len(nrow(.x)), size = floor(0.8 * nrow(.x)))
train <- .x[idx, ]
test <- .x[-idx, ]

model <- lm(
  price ~ calculated_host_listings_count +
    number_of_reviews +
    number_of_reviews_ltm +
    reviews_per_month +
    availability_365 +
    room_type,
  data = train
)

pred <- predict(model, newdata = test)

tibble(
  city = unique(.x$city),
  r2 = cor(test$price, pred, use = "complete.obs")^2,
  price_real = test$price,
  price_pred = pred
)

}) %>%
bind_rows()

models

```

## 9.4 Droite de r√©gression (r√©gression simple) : price \~ accommodates

```{r}

ggplot(ml_df, aes(x = availability_365, y = price)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(~city, scales = "free_y") +
  labs(
    title = "R√©gression lin√©aire simple : Prix ~ Disponibilit√© (par ville)",
    x = "Disponibilit√© sur 365 jours (availability_365)",
    y = "Prix (‚Ç¨)"
  ) +
  theme_minimal()

ggsave("../figures/regression_simple_by_city.png",
       width = 10, height = 5)

```

## 9.5 Graphique 3D (r√©gression multiple) ‚Äî exemple avec 3 variables

```{r}
## On prend un √©chantillon pour √©viter trop de points
set.seed(42)

ml_sample <- ml_df %>%
group_by(city) %>%
group_modify(~{
k <- min(800, nrow(.x))
dplyr::slice_sample(.x, n = k)
}) %>%
ungroup()

p3d <- plot_ly(
ml_sample,
x = ~availability_365,
y = ~reviews_per_month,
z = ~price,
color = ~city,
type = "scatter3d",
mode = "markers",
marker = list(size = 2, opacity = 0.5)
) %>%
layout(
title = "3D : Prix vs Disponibilit√© vs Activit√© (par ville)",
scene = list(
xaxis = list(title = "availability_365"),
yaxis = list(title = "reviews_per_month"),
zaxis = list(title = "price (‚Ç¨)")
)
)

p3d

```

## =======================================================

## üîü Graphiques de synth√®se (top soutenance)

## =======================================================

## 10.1 Top 10 types de logements les plus chers (par ville) ‚Äî property_type

```{r}
top_neighbourhood <- listings_all_clean %>%
filter(!is.na(neighbourhood), !is.na(price)) %>%
group_by(city, neighbourhood) %>%
summarise(
mean_price = mean(price, na.rm = TRUE),
n = n(),
.groups = "drop"
) %>%
filter(n >= 30) %>% # √©vite les quartiers trop rares
group_by(city) %>%
slice_max(mean_price, n = 10) %>%
ungroup()

ggplot(top_neighbourhood,
aes(x = reorder(neighbourhood, mean_price), y = mean_price)) +
geom_col() +
coord_flip() +
facet_wrap(~city, scales = "free") +
labs(
title = "Top 10 quartiers (neighbourhood) les plus chers par ville",
x = NULL,
y = "Prix moyen (‚Ç¨)"
) +
theme_minimal()

```

## 10.2 Comparaison prix moyen / note moyenne par ville

```{r}
ggplot(ml_df, aes(x = reviews_per_month, y = price, color = city)) +
geom_point(alpha = 0.15) +
geom_smooth(method = "lm", se = FALSE) +
labs(
title = "Impact de l'activit√© (reviews_per_month) sur le prix ‚Äî 3 villes",
x = "Avis par mois (reviews_per_month)",
y = "Prix (‚Ç¨)"
) +
theme_minimal()


```

## 10.3 Impact capacit√© ‚Üí prix (3 courbes sur un m√™me graphe)

```{r}
ggplot(ml_df, aes(x = availability_365, y = price, color = city)) + geom_point(alpha = 0.15) + geom_smooth(method = "lm", se = FALSE) + labs( title = "Impact de la disponibilit√© (availability_365) sur le prix ‚Äî comparaison 3 villes", x = "Disponibilit√© sur 365 jours", y = "Prix (‚Ç¨)" ) + theme_minimal()

ggsave("../figures/impact_availability_price_3cities.png", width = 10, height = 5)
```

## EXPORT JSON

```{r}
library(dplyr)
library(readr)
library(jsonlite)

# Charger tes CSV nettoy√©s
lp <- read_csv("../data_cleaned/paris/listings_paris_cleaned.csv")
lb <- read_csv("../data_cleaned/bordeaux/listings_bordeaux_cleaned.csv")
ll <- read_csv("../data_cleaned/lyon/listings_lyon_cleaned.csv")

# 1) Totaux annonces
total_listings <- tibble(
  city = c("Paris","Bordeaux","Lyon"),
  total = c(nrow(lp), nrow(lb), nrow(ll))
)

# 2) Stats prix
city_list <- list(Paris = lp, Bordeaux = lb, Lyon = ll)
price_stats <- lapply(names(city_list), function(city) {
  df <- city_list[[city]]
  summarise(df,
    city = city,
    mean   = mean(price, na.rm=TRUE),
    median = median(price, na.rm=TRUE),
    min    = min(price, na.rm=TRUE),
    max    = max(price, na.rm=TRUE)
  )
}) |> bind_rows()

# 3) Distribution prix (bins align√©s)
bin_edges <- seq(0, 500, by = 50)
make_bins <- function(df) {
  cut(df$price, breaks = c(bin_edges, Inf), right = FALSE, include.lowest = TRUE) |>
    table() |>
    as.data.frame() |>
    transmute(
      range = gsub("\\[|\\)|\\[|\\)", "", Var1),
      count = Freq
    )
}
price_distribution <- list(
  Paris    = make_bins(lp),
  Bordeaux = make_bins(lb),
  Lyon     = make_bins(ll)
)

# 4) Room types
room_type_list <- list(
  Paris    = count(lp, room_type, name = "count"),
  Bordeaux = count(lb, room_type, name = "count"),
  Lyon     = count(ll, room_type, name = "count")
)
room_type_distribution <- lapply(names(room_type_list), function(city) {
  df <- room_type_list[[city]]
  mutate(df, percentage = round(count/sum(count)*100,1), type = room_type) |> select(type, count, percentage)
})
names(room_type_distribution) <- names(room_type_list)

# 5) H√¥tes
hosts_list <- list(Paris = lp, Bordeaux = lb, Lyon = ll)
hosts_analysis <- lapply(names(hosts_list), function(city) {
  df <- hosts_list[[city]]
  df |>
    filter(!is.na(calculated_host_listings_count)) |>
    mutate(host_type = if_else(calculated_host_listings_count <= 1, "1 logement", "Multi-logements")) |>
    count(host_type, name = "count") |>
    mutate(percentage = round(count/sum(count)*100,1),
           type = host_type) |>
    select(type, count, percentage)
})
names(hosts_analysis) <- names(hosts_list)

# 6) ML perf (exemple simple lin√©aire sur availability_365)
ml_list <- list(Paris = lp, Bordeaux = lb, Lyon = ll)
ml_model_results <- lapply(names(ml_list), function(city) {
  df <- ml_list[[city]]
  df2 <- df |> tidyr::drop_na(price, availability_365)
  m <- lm(price ~ availability_365, data = df2)
  preds <- predict(m, df2)
  tibble(city = city,
         r2   = cor(df2$price, preds)^2,
         rmse = sqrt(mean((df2$price - preds)^2)))
}) |> bind_rows()

# 7) Prix vs #logements h√¥te (√©chantillon)
set.seed(42)
sample_price_vs_host <- function(df, n = 400) {
  df |> filter(!is.na(price), !is.na(calculated_host_listings_count)) |>
    slice_sample(n = min(n, nrow(df))) |>
    transmute(hostListings = calculated_host_listings_count, price = price)
}
price_vs_host_listings <- list(
  Paris    = sample_price_vs_host(lp),
  Bordeaux = sample_price_vs_host(lb),
  Lyon     = sample_price_vs_host(ll)
)

# 8) Predicted vs Actual (r√©utilise m ci-dessus ou un autre mod√®le)
predicted_vs_actual <- list(
  Paris    = { df <- lp |> tidyr::drop_na(price, availability_365); m <- lm(price ~ availability_365, df); tibble(actual = df$price, predicted = predict(m, df)) },
  Bordeaux = { df <- lb |> tidyr::drop_na(price, availability_365); m <- lm(price ~ availability_365, df); tibble(actual = df$price, predicted = predict(m, df)) },
  Lyon     = { df <- ll |> tidyr::drop_na(price, availability_365); m <- lm(price ~ availability_365, df); tibble(actual = df$price, predicted = predict(m, df)) }
)

# 9) Top quartiers
top_neigh_list <- list(Paris = lp, Bordeaux = lb, Lyon = ll)
top_neighbourhoods <- lapply(names(top_neigh_list), function(city) {
  df <- top_neigh_list[[city]]
  df |>
    filter(!is.na(neighbourhood), !is.na(price)) |>
    group_by(neighbourhood) |>
    summarise(meanPrice = mean(price), n = n(), .groups="drop") |>
    filter(n >= 30) |>
    slice_max(meanPrice, n = 10) |>
    arrange(desc(meanPrice))
})
names(top_neighbourhoods) <- names(top_neigh_list)

# 10) Outliers (IQR) + boxplot
iqr_clean <- function(df) {
  q1 <- quantile(df$price, 0.25, na.rm = TRUE)
  q3 <- quantile(df$price, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  filter(df, price >= q1 - 1.5*iqr, price <= q3 + 1.5*iqr)
}
boxplot_list <- list(Paris = lp, Bordeaux = lb, Lyon = ll)
boxplot_data <- lapply(names(boxplot_list), function(city) {
  df <- boxplot_list[[city]]
  q1 <- quantile(df$price, 0.25, na.rm = TRUE)
  q3 <- quantile(df$price, 0.75, na.rm = TRUE)
  list(
    q1 = unname(q1),
    median = unname(median(df$price, na.rm=TRUE)),
    q3 = unname(q3),
    min = min(df$price, na.rm=TRUE),
    max = max(df$price, na.rm=TRUE)
  )
})
names(boxplot_data) <- names(boxplot_list)

outlier_list <- list(Paris = lp, Bordeaux = lb, Lyon = ll)
outlier_cleaning <- lapply(names(outlier_list), function(city) {
  df <- outlier_list[[city]]
  before <- df
  after  <- iqr_clean(df)
  list(
    before = list(count = nrow(before), mean = mean(before$price, na.rm=TRUE), median = median(before$price, na.rm=TRUE)),
    after  = list(count = nrow(after),  mean = mean(after$price,  na.rm=TRUE), median = median(after$price,  na.rm=TRUE))
  )
})
names(outlier_cleaning) <- names(outlier_list)

# 11) 3D / availability / reviews impacts (√©chantillons)
availability_impact <- list(
  Paris    = lp |> transmute(availability = availability_365, price = price),
  Bordeaux = lb |> transmute(availability = availability_365, price = price),
  Lyon     = ll |> transmute(availability = availability_365, price = price)
)

reviews_impact <- list(
  Paris    = lp |> transmute(reviewsPerMonth = reviews_per_month, price = price),
  Bordeaux = lb |> transmute(reviewsPerMonth = reviews_per_month, price = price),
  Lyon     = ll |> transmute(reviewsPerMonth = reviews_per_month, price = price)
)

data3d <- list(
  Paris    = lp |> slice_sample(n = min(800, nrow(lp))) |> transmute(x = availability_365, y = reviews_per_month, z = price),
  Bordeaux = lb |> slice_sample(n = min(600, nrow(lb))) |> transmute(x = availability_365, y = reviews_per_month, z = price),
  Lyon     = ll |> slice_sample(n = min(600, nrow(ll))) |> transmute(x = availability_365, y = reviews_per_month, z = price)
)

# 12) KPIs synth√®se
summary_kpis <- list(
  totalListings = nrow(lp) + nrow(lb) + nrow(ll),
  averagePrice  = mean(c(lp$price, lb$price, ll$price), na.rm=TRUE),
  totalCities   = 3,
  avgR2Score    = mean(ml_model_results$r2, na.rm=TRUE)
)

# √âcrire un seul JSON accessible depuis le front
# Cible : public/data/mockData.json pour acc√®s direct sans build

# Determine output path - adapt based on your working directory
output_path <- here::here("public", "data", "mockData.json")
dir.create(dirname(output_path), recursive = TRUE, showWarnings = FALSE)

jsonlite::write_json(
  list(
    totalListings = total_listings,
    priceStats = price_stats,
    roomTypeDistribution = room_type_distribution,
    priceDistribution = price_distribution,
    hostsAnalysis = hosts_analysis,
    priceVsHostListings = price_vs_host_listings,
    boxplotData = boxplot_data,
    outlierCleaningData = outlier_cleaning,
    mlModelResults = ml_model_results,
    predictedVsActual = predicted_vs_actual,
    topNeighbourhoods = top_neighbourhoods,
    availabilityImpact = availability_impact,
    reviewsImpact = reviews_impact,
    data3D = data3d,
    summaryKPIs = summary_kpis
  ),
  output_path,
  auto_unbox = TRUE,
  pretty = TRUE
)

cat("‚úì JSON export√© vers:", output_path, "\n")
```